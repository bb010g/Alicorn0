// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
{% import "macros.rs" as rs %}

::uniffi_alicorn::setup_alicorn_scaffolding!("{{ ci.namespace() }}");

fn uniffi_alicorn_{{ci.namespace()}}_setup<'a>(uniffi_alicorn_{{ci.namespace()}}_alicorn: &'a ::alicorn::Alicorn) -> ::mlua::Result<&'static str> {
    let uniffi_alicorn_{{ci.namespace()}}_lua = &uniffi_alicorn_{{ci.namespace()}}_alicorn.lua;
    let uniffi_alicorn_{{ci.namespace()}}_package_loaded = uniffi_alicorn_{{ci.namespace()}}_lua.globals().get::<::mlua::Table>("package")?.get::<::mlua::Table>("loaded")?;
    let uniffi_alicorn_{{ci.namespace()}}_host_data = uniffi_alicorn_{{ci.namespace()}}_lua.create_table()?;
    uniffi_alicorn_{{ci.namespace()}}_package_loaded.set("uniffi-alicorn-host-{{ci.namespace()}}", uniffi_alicorn_{{ci.namespace()}}_host_data)?;

    {% for e in ci.enum_definitions() %}
    {% if ci.is_name_used_as_error(e.name()) %}
    // Error definitions, corresponding to `error` in the UDL.
    {# include "alicorn/ErrorTemplate.rs" #}
    {% else %}
    // Enum definitions, corresponding to `enum` in UDL.
    {# include "alicorn/EnumTemplate.rs" #}
    {% endif %}
    {% endfor %}

    // Record definitions, implemented as method-less structs, corresponding to `dictionary` objects.
    {% for rec in ci.record_definitions() %}
    {# include "alicorn/RecordTemplate.rs" #}
    {% endfor %}

    // Top level functions, corresponding to UDL `namespace` functions.
    let uniffi_alicorn_{{ci.namespace()}}_host_funcs = uniffi_alicorn_{{ci.namespace()}}_lua.create_table()?;
    uniffi_alicorn_{{ci.namespace()}}_host_data.set("funcs", uniffi_alicorn_{{ci.namespace()}}_host_funcs)?;
    {%- for func in ci.function_definitions() %}
    uniffi_alicorn_{{ci.namespace()}}_host_funcs.set("{{ func.name() }}", uniffi_alicorn_{{ci.namespace()}}_lua.create_function(
            |uniffi_alicorn_{{ci.namespace()}}_lua, ({% for arg in func.arguments() %}r#{{ arg.name() }}, {%- endfor %}): ({%- for arg in func.arguments() %}{% if arg.by_ref() %}&{% endif %}{{ arg.as_type().borrow()|type_rs }}, {% endfor %})|
                {%- match (func.return_type(), func.throws_type()) %}
                {%- when (Some(return_type), None) %} -> ::mlua::Result<{{ return_type|type_rs }}>
                {%- when (Some(return_type), Some(error_type)) %} -> ::mlua::Result<::std::result::Result::<{{ return_type|type_rs }}, {{ error_type|type_rs }}>>
                {%- when (None, Some(error_type)) %} -> ::mlua::Result<::std::result::Result::<(), {{ error_type|type_rs }}>>
                {%- when (None, None) %} -> ::mlua::Result<()>
                {%- endmatch %}
            { ::core::result::Result::Ok({{ func.name() }}({%- for arg in func.arguments() %}r#{{ arg.name() }},{% endfor %})) }
    )?);
    {% endfor -%}

    // Object definitions, corresponding to UDL `interface` definitions.
    let uniffi_alicorn_{{ci.namespace()}}_host_methods = uniffi_alicorn_{{ci.namespace()}}_lua.create_table()?;
    uniffi_alicorn_{{ci.namespace()}}_host_data.set("methods", uniffi_alicorn_{{ci.namespace()}}_host_methods)?;
    {% for obj in ci.object_definitions() %}
    let uniffi_alicorn_{{ci.namespace()}}_host_obj_methods = uniffi_alicorn_{{ci.namespace()}}_lua.create_table()?;
    uniffi_alicorn_{{ci.namespace()}}_host_methods.set("{{obj.name()}}", uniffi_alicorn_{{ci.namespace()}}_host_obj_methods)?;
    {%- for meth in obj.methods() %}
    uniffi_alicorn_{{ci.namespace()}}_host_methods.set("{{ meth.name() }}", uniffi_alicorn_{{ci.namespace()}}_lua.create_function(
            |uniffi_alicorn_{{ci.namespace()}}_lua, (uniffi_alicorn_self,{% for arg in meth.arguments() %} r#{{ arg.name() }}, {%- endfor %}): ({% if meth.takes_self_by_arc()%}{{&obj.as_type()|type_rs}}{% else %}&dyn {{obj.name()}}{% endif %}, {% for arg in meth.arguments() %}{% if arg.by_ref() %}&{% endif %}{{ arg.as_type().borrow()|type_rs }}, {% endfor %})|
                {%- match (meth.return_type(), meth.throws_type()) %}
                {%- when (Some(return_type), None) %} -> ::mlua::Result<{{ return_type|type_rs }}>
                {%- when (Some(return_type), Some(error_type)) %} -> ::mlua::Result<::std::result::Result::<{{ return_type|type_rs }}, {{ error_type|type_rs }}>>
                {%- when (None, Some(error_type)) %} -> ::mlua::Result<::std::result::Result::<(), {{ error_type|type_rs }}>>
                {%- when (None, None) %} -> ::mlua::Result<()>
                {%- endmatch %}
            { ::core::result::Result::Ok({{ obj.name() }}::{{ meth.name() }}(uniffi_alicorn_self,{% for arg in meth.arguments() %} r#{{ arg.name() }}, {%- endfor %})) }
    )?);
    {% endfor -%}
    {% endfor %}

    // Callback Interface definitions, corresponding to UDL `callback interface` definitions.
    {% for cbi in ci.callback_interface_definitions() %}
    {# include "alicorn/CallbackInterfaceTemplate.rs" #}
    {% endfor %}

    ::core::result::Result::Ok(r######"{% include "alicorn/scaffolding_template.alc" %}"######)
}
